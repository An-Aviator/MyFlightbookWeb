using DotNetOpenAuth.OAuth2;
using Dropbox.Api;
using MyFlightbook.OAuth;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.IO;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Runtime.Serialization;
using System.Threading.Tasks;
using System.Web;

/******************************************************
 * 
 * Copyright (c) 2016-2020 MyFlightbook LLC
 * Contact myflightbook-at-gmail.com for more information
 *
*******************************************************/

namespace MyFlightbook.CloudStorage
{
    /// <summary>
    /// Specifies the default cloud storage to use for a given user if they've authorized more than one.
    /// </summary>
    public enum StorageID { None, Dropbox, GoogleDrive, OneDrive, iCloud }

    /// <summary>
    /// Base class for cloud storage
    /// </summary>
    public abstract class CloudStorageBase : OAuthClientBase
    {
        /// <summary>
        /// Creates a cloud storage provider using parameters for oAuth authentication and token retrieval
        /// </summary>
        /// <param name="szAppKeyKey">The LocalConfig key for the oAuth2 appeky</param>
        /// <param name="szAppSecretKey">The LocalConfig key for the oAuth2 secret</param>
        /// <param name="szOAuth2AuthEndpoint">The oAuth2 authorization endpoint URL</param>
        /// <param name="szOAuth2TokenEndpoint">The oAuth2 token endpoint URL</param>
        /// <param name="scopes">Array of scopes for oAuth</param>
        protected CloudStorageBase(string szAppKeyKey, string szAppSecretKey, string szOAuth2AuthEndpoint, string szOAuth2TokenEndpoint, string[] scopes = null, string szUpgradeEndpoint = null, string szDisableEndpoint = null) : 
            base(szAppKeyKey, szAppSecretKey, szOAuth2AuthEndpoint, szOAuth2TokenEndpoint, scopes, szUpgradeEndpoint, szDisableEndpoint)
        {
        }

        public static string CloudStorageName(StorageID sid)
        {
            switch (sid)
            {
                case StorageID.Dropbox:
                    return Resources.LocalizedText.CloudStorageDropbox;
                case StorageID.GoogleDrive:
                    return Resources.LocalizedText.CloudStorageGDrive;
                case StorageID.iCloud:
                    return Resources.LocalizedText.CloudStorageICloud;
                case StorageID.OneDrive:
                    return Resources.LocalizedText.CloudStorageOneDrive;
                case StorageID.None:
                default:
                    return string.Empty;
            }
        }
    }

    #region Google Drive
    #region Google Drive Errors
    /*
     * Generated by Xamasoft JSON Class Generator http://www.xamasoft.com/json-class-generator
     */
    [Serializable]
    public class GoogleDriveInternalError
    {

        [JsonProperty("domain")]
        public string domain { get; set; }

        [JsonProperty("reason")]
        public string reason { get; set; }

        [JsonProperty("message")]
        public string message { get; set; }
    }

    [Serializable]
    public class GoogleDriveError
    {

        [JsonProperty("errors")]
        public Collection<GoogleDriveInternalError> errors { get; private set; }

        [JsonProperty("code")]
        public int code { get; set; }

        [JsonProperty("message")]
        public string message { get; set; }

        public GoogleDriveError()
        {
            errors = new Collection<GoogleDriveInternalError>();
        }
    }
    #endregion

    [Serializable]
    public class GoogleDriveResultDictionary : Dictionary<string, string>
    {
        public GoogleDriveResultDictionary(int capacity) : base(capacity)
        {
        }

        public GoogleDriveResultDictionary(IEqualityComparer<string> comparer) : base(comparer)
        {
        }

        public GoogleDriveResultDictionary(IDictionary<string, string> dictionary) : base(dictionary)
        {
        }

        public GoogleDriveResultDictionary(int capacity, IEqualityComparer<string> comparer) : base(capacity, comparer)
        {
        }

        public GoogleDriveResultDictionary(IDictionary<string, string> dictionary, IEqualityComparer<string> comparer) : base(dictionary, comparer)
        {
        }

        protected GoogleDriveResultDictionary() : base() { }

        protected GoogleDriveResultDictionary(SerializationInfo info, StreamingContext context) : base(info, context)
        {
        }
    }

    /// <summary>
    /// Provides utilities for using GoogleDrive from MyFlightbook
    /// </summary>
    public class GoogleDrive : CloudStorageBase
    {
        #region response data
        protected class GoogleDriveFileMetadata
        {
            public string kind { get; set; }
            public string id { get; set; }
            public string name { get; set; }
            public string mimeType { get; set; }
            public GoogleDriveFileMetadata() {  }
        }

        protected class GoogleFileList
        {
            public GoogleFileList() { files = new Collection<GoogleDriveFileMetadata>(); }

            public string kind { get; set; }
            public Collection<GoogleDriveFileMetadata> files {get; private set;}
        }
        #endregion

        public const string szParamGDriveAuth = "gdOAuth";

        private const string szURLUploadEndpoint = "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart";
        private const string szURLUpdateEndpointTemplate = "https://www.googleapis.com/upload/drive/v3/files/{0}?uploadType=multipart";
        private const string szURLViewFilesEndpointTemplate = "https://www.googleapis.com/drive/v3/files?q={0}&access_token={1}";
        private string RootFolderID { get; set; }

        public GoogleDrive(string szRootPath = "")
            : base("GoogleDriveAccessID", "GoogleDriveClientSecret", "https://accounts.google.com/o/oauth2/v2/auth?access_type=offline&prompt=consent", "https://www.googleapis.com/oauth2/v4/token", new string[] { "https://www.googleapis.com/auth/drive.appdata", "https://www.googleapis.com/auth/drive.file" })
        {
            RootPath = String.IsNullOrEmpty(szRootPath) ? Branding.CurrentBrand.AppName : szRootPath;
            RootFolderID = string.Empty;
        }

        public GoogleDrive(IAuthorizationState authstate) : this(MyFlightbook.Branding.CurrentBrand.AppName)
        {
            AuthState = authstate;
        }

        public override AuthorizationState ConvertToken(HttpRequest Request)
        {
            if (Request == null)
                throw new ArgumentNullException(nameof(Request));

            HttpWebRequest hr = (HttpWebRequest)HttpWebRequest.Create(new Uri(oAuth2TokenEndpoint));
            hr.Method = "POST";
            hr.ContentType = "application/x-www-form-urlencoded";

            string szPostData = String.Format(CultureInfo.InvariantCulture, "code={0}&client_id={1}&client_secret={2}&redirect_uri={3}&grant_type=authorization_code",
                    Request["code"],
                    AppKey,
                    AppSecret,
                    RedirectUri(Request, Request.Path, szParamGDriveAuth).ToString());

            byte[] rgbData = System.Text.Encoding.UTF8.GetBytes(szPostData);
            hr.ContentLength = rgbData.Length;
            using (Stream s = hr.GetRequestStream())
            {
                s.Write(rgbData, 0, rgbData.Length);
            }

            WebResponse response = hr.GetResponse();
            using (StreamReader sr = new StreamReader(response.GetResponseStream()))
            {
                string result = sr.ReadToEnd();

                // JSonConvert can't deserialize space-delimited scopes into a hashset, so we need to do that manually.  Uggh.
                Dictionary<string, string> d = JsonConvert.DeserializeObject<Dictionary<string, string>>(result);

                AuthorizationState authstate = new AuthorizationState(d.ContainsKey("scope") ? OAuthUtilities.SplitScopes(d["scope"]) : null)
                {
                    AccessToken = d.ContainsKey("access_token") ? d["access_token"] : string.Empty,
                    AccessTokenIssueDateUtc = DateTime.UtcNow
                };
                if (d.ContainsKey("expires_in"))
                {
                    if (int.TryParse(d["expires_in"], NumberStyles.Integer, CultureInfo.InvariantCulture, out int exp))
                        authstate.AccessTokenExpirationUtc = DateTime.UtcNow.AddSeconds(exp);
                }
                authstate.RefreshToken = d.ContainsKey("refresh_token") ? d["refresh_token"] : string.Empty;

                return authstate;
            }
        }

        protected async Task<string> CreateFolder(string szFolderName)
        {
            HttpResponseMessage response = null;

            string szResult = string.Empty;

            using (HttpClient httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("Authorization", "Bearer " + AuthState.AccessToken);

                // Create the metadata.  Name is most important, but we can also specify mimeType for CSV to import into GoogleDocs
                Dictionary<string, string> dictMeta = new Dictionary<string, string>() { { "name", szFolderName }, { "mimeType", "application/vnd.google-apps.folder" } };

                // Create the form.  The form itself needs the authtoken header
                using (MultipartContent form = new MultipartContent("related"))
                {
                    // Next add the metadata - it is in Json format
                    using (StringContent metadata = new StringContent(JsonConvert.SerializeObject(dictMeta)))
                    {
                        metadata.Headers.ContentType = new MediaTypeHeaderValue("application/json");
                        form.Add(metadata);

                        try
                        {
                            response = await httpClient.PostAsync(new Uri(szURLUploadEndpoint), form).ConfigureAwait(false);
                            szResult = response.Content.ReadAsStringAsync().Result;
                            response.EnsureSuccessStatusCode();
                            if (!String.IsNullOrEmpty(szResult))
                            {
                                GoogleDriveFileMetadata gfm = JsonConvert.DeserializeObject<GoogleDriveFileMetadata>(szResult);
                                if (gfm != null)
                                    return gfm.id;
                            }
                        }
                        catch (System.Net.Http.HttpRequestException ex)
                        {
                            if (response == null)
                                throw new MyFlightbookException("Unknown error in GoogleDrive.CreateFolder", ex);
                            else
                                throw new MyFlightbookException(response.ReasonPhrase + " " + szResult);
                        }
                        finally
                        {
                            if (response != null)
                                response.Dispose();
                        }
                    }
                }

                return string.Empty;
            }
        }

        #region Finding files and folders on GoogleDrive
        /// <summary>
        /// Returns the URL-based query for Google drive to look for a folder with the specified name
        /// </summary>
        /// <param name="szFolderName">The name of the folder</param>
        /// <returns>The ID of the resulting object (if found)</returns>
        protected static string FolderQuery(string szFolderName)
        {
            return String.Format(System.Globalization.CultureInfo.InvariantCulture, "name%3D'{0}'+and+mimeType%3D'application%2Fvnd.google-apps.folder'", szFolderName);
        }

        /// <summary>
        /// Returns the URL-based query for Google drive to look for a file with the specified name
        /// </summary>
        /// <param name="szFileName">The name of the file</param>
        /// <param name="szParent">The ID of the parent folder</param>
        /// <returns>The ID of the resulting object (if found)</returns>
        protected static string FileQuery(string szFileName, string szParent)
        {
            return String.Format(System.Globalization.CultureInfo.InvariantCulture, "name%3D'{0}'+and+'{1}'+in+parents+and+trashed%3Dfalse", szFileName, szParent);
        }

        /// <summary>
        /// Executes the specified search query, returning the ID of the first object that is found
        /// </summary>
        /// <param name="szQuery">Query (use FolderQuery or FileQuery)</param>
        /// <returns>The ID of the resulting object (if found), else string.empty</returns>
        protected async Task<string> FindIDForQuery(string szQuery)
        {
            // See if the folder exists
            Uri uri = new Uri(String.Format(CultureInfo.InvariantCulture, szURLViewFilesEndpointTemplate, szQuery, AuthState.AccessToken));

            HttpResponseMessage response = null;

            using (HttpClient httpClient = new HttpClient())
            {
                try
                {
                    response = await httpClient.GetAsync(uri).ConfigureAwait(false);
                    response.EnsureSuccessStatusCode();
                    string szResult = response.Content.ReadAsStringAsync().Result;
                    if (!String.IsNullOrEmpty(szResult))
                    {
                        GoogleFileList gfl = JsonConvert.DeserializeObject<GoogleFileList>(szResult);
                        if (gfl != null && gfl.files.Count > 0)
                            return gfl.files[0].id;
                    }
                }
                catch (System.Net.Http.HttpRequestException ex)
                {
                    if (response == null)
                        throw new MyFlightbookException("Unknown error in GoogleDrive.GetFolderID", ex);
                    else
                        throw new MyFlightbookException(response.ReasonPhrase);
                }
                finally
                {
                    if (response != null)
                        response.Dispose();
                }
            }

            return string.Empty;
        }

        protected async Task<string> IDForFolder(string szFoldername)
        {
            return await FindIDForQuery(FolderQuery(szFoldername)).ConfigureAwait(false);
        }

        protected async Task<string> IDForFile(string szFileName, string szParentID)
        {
            return await FindIDForQuery(FileQuery(szFileName, szParentID)).ConfigureAwait(false);
        }
        #endregion

        /// <summary>
        /// Put's a file as an array of bytes
        /// </summary>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="rgData">The array of bytes</param>
        /// <param name="szMimeType">The mime type for the data</param>
        /// <returns>True for success</returns>
        /// <exception cref="MyFlightbookException"></exception>
        public async Task<GoogleDriveResultDictionary> PutFile(string szFileName, byte[] rgData, string szMimeType)
        {
            using (MemoryStream ms = new MemoryStream(rgData))
            {
                return await PutFile(ms, szFileName, szMimeType).ConfigureAwait(false);
            }
        }

        private static void ThrowGDriveError(Exception ex)
        {
            if (ex == null)
                return;
            GDriveError error = JsonConvert.DeserializeObject<GDriveError>(ExtractResponseString(ex.InnerException as WebException));
            if (error == null)
                throw new MyFlightbookException("Unknown error refreshing access token", ex);
            else if (error.error.CompareCurrentCultureIgnoreCase("invalid_grant") == 0)
                throw new UnauthorizedAccessException(Branding.ReBrand(Resources.LocalizedText.GoogleDriveBadAuth), ex);
            else
                throw new MyFlightbookException(String.Format(CultureInfo.CurrentCulture, "Error from Google Drive: {0} {1} {2}", error.error, error.error_description, error.error_link), ex);
        }

        /// <summary>
        /// Put's a file as a stream using the REST API documented at https://developers.google.com/drive/v3/web/manage-uploads#multipart
        /// </summary>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="ms">The stream of the data</param>
        /// <param name="szMimeType">The mime type for the data</param>
        /// <returns>True for success</returns>
        /// <exception cref="MyFlightbookException"></exception>
        /// <exception cref="System.Net.Http.HttpRequestException"></exception>
        public async Task<GoogleDriveResultDictionary> PutFile(Stream ms, string szFileName, string szMimeType)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));

            try
            {
                await RefreshAccessToken().ConfigureAwait(false);
            }
            catch (DotNetOpenAuth.Messaging.ProtocolException ex)
            {
                ThrowGDriveError(ex);
            }

            bool fIsCSV = szMimeType.CompareCurrentCultureIgnoreCase("text/csv") == 0;

            ms.Seek(0, SeekOrigin.Begin);   // write out the whole stream.  UploadAsync appears to pick up from the current location, which is the end-of-file after writing to a ZIP.

            string szResult = string.Empty;
            HttpResponseMessage response = null;

            using (HttpClient httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("Authorization", "Bearer " + AuthState.AccessToken);

                if (String.IsNullOrEmpty(RootFolderID))
                {
                    RootFolderID = await IDForFolder(RootPath).ConfigureAwait(false);
                    if (String.IsNullOrEmpty(RootFolderID))
                        RootFolderID = await CreateFolder(Branding.CurrentBrand.AppName).ConfigureAwait(false);
                }

                // CSV loses its extension when uploaded because we map it to a google spreadsheet.  So if it's CSV AND we are patching an existing file, drop the extension so that we ov
                // update the existing file if it is present.  If CSV, strip the extension
                string szFileNameToCheck = fIsCSV ? Path.GetFileNameWithoutExtension(szFileName) : szFileName;
                string idExisting = null;
                if (!String.IsNullOrEmpty(RootFolderID))
                    idExisting = await IDForFile(szFileNameToCheck, RootFolderID).ConfigureAwait(false);

                // If we got a hit, use that filename for the udpate
                if (!String.IsNullOrEmpty(idExisting))
                    szFileName = szFileNameToCheck;

                // Create the metadata.  Name is most important, but we can also specify mimeType for CSV to import into GoogleDocs
                Dictionary<string, object> dictMeta = new Dictionary<string, object>() { { "name", szFileName } };
                if (fIsCSV)
                    dictMeta["mimeType"] = "application/vnd.google-apps.spreadsheet";   // get it to show up in google drive sheets.
                if (String.IsNullOrEmpty(idExisting) && !String.IsNullOrEmpty(RootFolderID))
                    dictMeta["parents"] = new List<string>() { RootFolderID };

                // Create the form.  The form itself needs the authtoken header
                using (MultipartContent form = new MultipartContent("related"))
                {
                    // Next add the metadata - it is in Json format
                    string szJSonMeta = JsonConvert.SerializeObject(dictMeta);
                    using (StringContent metadata = new StringContent(szJSonMeta, System.Text.Encoding.UTF8))
                    {
                        metadata.Headers.ContentType = new MediaTypeHeaderValue("application/json") { CharSet = "UTF-8" };
                        form.Add(metadata);

                        // Finally, add the body, with its appropriate mime type.
                        using (StreamContent body = new StreamContent(ms))
                        {
                            body.Headers.ContentType = new MediaTypeHeaderValue(szMimeType);
                            form.Add(body);

                            try
                            {
                                response = (String.IsNullOrEmpty(idExisting)) ?
                                    await httpClient.PostAsync(new Uri(szURLUploadEndpoint), form).ConfigureAwait(false) :
                                    await httpClient.PatchAsync(new Uri(String.Format(CultureInfo.InvariantCulture, szURLUpdateEndpointTemplate, idExisting)), form, false).ConfigureAwait(false);
                                szResult = response.Content.ReadAsStringAsync().Result;
                                response.EnsureSuccessStatusCode();
                                return (String.IsNullOrEmpty(szResult)) ? null : JsonConvert.DeserializeObject<GoogleDriveResultDictionary>(szResult);
                            }
                            catch (HttpRequestException ex)
                            {
                                if (response == null)
                                    throw new MyFlightbookException("Unknown error in GoogleDrive.PutFile", ex);

                                Dictionary<string, GoogleDriveError> d = String.IsNullOrEmpty(szResult) ? null : JsonConvert.DeserializeObject<Dictionary<string, GoogleDriveError>>(szResult);
                                GoogleDriveError gde = (d == null || !d.ContainsKey("error")) ? null : d["error"];

                                if (gde != null && gde.code == 403 && gde.errors != null && gde.errors.Count > 0 && gde.errors[0].reason != null && gde.errors[0].reason.CompareCurrentCultureIgnoreCase("storageQuotaExceeded") == 0)
                                    throw new MyFlightbookException(Resources.LocalizedText.GoogleDriveOutOfSpace);
                                else
                                    throw new MyFlightbookException(response.ReasonPhrase + " " + (szResult ?? string.Empty));
                            }
                            finally
                            {
                                if (response != null)
                                    response.Dispose();
                            }
                        }
                    }
                }
            }
        }
    }
    #endregion

    #region OneDrive
    public enum OneDriveErrorCodeMFB
    {
        Unknown = -1,
        AccessDenied = 0,
        ActivityLimitReached = 1,
        AuthenticationCancelled = 2,
        AuthenticationFailure = 3,
        GeneralException = 4,
        InvalidRange = 5,
        InvalidRequest = 6,
        ItemNotFound = 7,
        MalwareDetected = 8,
        MyFilesCapabilityNotFound = 9,
        NameAlreadyExists = 10,
        NotAllowed = 11,
        NotSupported = 12,
        ResourceModified = 13,
        ResyncRequired = 14,
        ServiceNotAvailable = 15,
        Timeout = 16,
        TooManyRedirects = 17,
        QuotaLimitReached = 18,
        Unauthenticated = 19,
        UserDoesNotHaveMyFilesService = 20
    }

    public class OneDriveError
    {
        OneDriveErrorCodeMFB ErrorCode { get; set; }

        public string Message { get; set; }

        public OneDriveError(OneDriveErrorCodeMFB errCode)
        {
            ErrorCode = errCode;
            Message = MessageForCode(errCode);
        }

        protected static string MessageForCode(OneDriveErrorCodeMFB errCode)
        {
            switch (errCode)
            {
                case OneDriveErrorCodeMFB.AccessDenied:
                case OneDriveErrorCodeMFB.AuthenticationCancelled:
                case OneDriveErrorCodeMFB.AuthenticationFailure:
                case OneDriveErrorCodeMFB.Unauthenticated:
                    return Branding.ReBrand(Resources.LocalizedText.OneDriveBadAuth);
                case OneDriveErrorCodeMFB.QuotaLimitReached:
                    return Resources.LocalizedText.OneDriveErrorOutOfSpace;
                case OneDriveErrorCodeMFB.Timeout:
                case OneDriveErrorCodeMFB.ServiceNotAvailable:
                case OneDriveErrorCodeMFB.TooManyRedirects:
                    return Resources.LocalizedText.OneDriveCantReachService;
                default:
                    return errCode.ToString();
            }
        }

        public OneDriveError(string szJSon) : base()
        {
            Message = string.Empty;
            ErrorCode = OneDriveErrorCodeMFB.Unknown;

            if (String.IsNullOrEmpty(szJSon))
                return;

            dynamic result = JObject.Parse(szJSon);

            try
            {
                string szCode = result.error.code;
                Message = result.error.message;

                if (Enum.TryParse(szCode, true, out OneDriveErrorCodeMFB errCode))
                    ErrorCode = errCode;
            }
            catch (Exception ex) when (ex is Microsoft.CSharp.RuntimeBinder.RuntimeBinderException) { }

            Message = MessageForCode(ErrorCode);

        }
  
        public override string ToString()
        {
            return String.Format(CultureInfo.CurrentCulture, "{0}: {1}", ErrorCode, Message);
        }
    }

    [Serializable]
    public class OneDriveMFBException : Exception
    {
        public OneDriveError Error { get; set; }
        public OneDriveMFBException(string message) : base(message)
        {
            Error = null;
        }

        public OneDriveMFBException(string message, Exception innerException) : base(message, innerException)
        {
            Error = null;
        }

        public OneDriveMFBException(OneDriveError err) : base(err == null ? string.Empty : err.Message)
        {
            Error = err;
        }
            
        public OneDriveMFBException(OneDriveError err, Exception innerException) : base(err == null ? string.Empty : err.Message, innerException)
        {
            Error = err;
        }

        public OneDriveMFBException()
        {
            Error = null;
        }

        protected OneDriveMFBException(SerializationInfo serializationInfo, StreamingContext streamingContext): base(serializationInfo, streamingContext)
        {
            Error = null;
        }

        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);

            info.AddValue("Error", Error);
        }
    }

    internal class OneDriveSession
    {
        [JsonProperty("uploadUrl")]
        public string UploadEndpoint { get; set; }

        public Uri UploadUri
        {
            get { return new Uri(UploadEndpoint ?? string.Empty); }
        }

        [JsonProperty("expirationDateTime")]
        public DateTime Expiration { get; set; }

        [JsonProperty("nextExpectedRanges")]
        public Collection<string> ExpectedRanges { get; set; }

        public OneDriveSession()
        {
            UploadEndpoint = string.Empty;
            ExpectedRanges = new Collection<string>();
            Expiration = DateTime.MinValue;
        }
    }

    /// <summary>
    /// Provides utilities for using OneDrive from MyFlightbook
    /// 
    /// Useful resources:
    ///   - oAuth flow and endpoints: https://dev.onedrive.com/auth/msa_oauth.htm
    ///   - Rest API for uploading: https://docs.microsoft.com/en-us/onedrive/developer/rest-api/concepts/upload?view=odsp-graph-online
    /// </summary>
    public class OneDrive : CloudStorageBase
    {
        public const string TokenSessionKey = "sessionkeyforonedrive";
        public const string szParam1DriveAuth = "1dOAuth";
        private const int MinFileSizeResumable = 4000000;   // files that are 4MB+ require a resumable upload.

        public OneDrive(string szRootPath = "") 
            : base("OneDriveAccessID", "OneDriveClientSecret", "https://login.live.com/oauth20_authorize.srf", "https://login.live.com/oauth20_token.srf", new string[] { "onedrive.appfolder", "wl.basic", "onedrive.readwrite", "wl.offline_access" })
        {
            RootPath = szRootPath;
        }

        public OneDrive(IAuthorizationState authstate) : this(MyFlightbook.Branding.CurrentBrand.AppName + "/")
        {
            AuthState = authstate;
        }

        protected static void HandleInvalidAuth(Exception ex)
        {
            if (ex == null)
                throw new ArgumentNullException(nameof(ex));

            dynamic error = JsonConvert.DeserializeObject(ExtractResponseString(ex.InnerException as WebException));
            if (error == null)
                throw new MyFlightbookException("Unknown error refreshing access token", ex);
            else if (error.error != null && String.Compare(error.error.ToString(), "invalid_grant", StringComparison.InvariantCulture) == 0)
            {
                OneDriveMFBException ode = new OneDriveMFBException(new OneDriveError(OneDriveErrorCodeMFB.AuthenticationFailure), ex);
                throw new UnauthorizedAccessException(ode.Message, ode);
            }
            else
                throw new MyFlightbookException(Branding.ReBrand(Resources.LocalizedText.OneDriveBadAuth));
        }

        private UriBuilder BuilderForPath(string szPath)
        {
            return new UriBuilder("https://api.onedrive.com")
            {
                Query = String.Format(CultureInfo.InvariantCulture, "access_token={0}", AuthState.AccessToken),
                Path = szPath
            };
        }

        internal async Task<OneDriveSession> GetResumableSession(string szFilename)
        {
            string szResult = string.Empty;
            HttpResponseMessage response = null;

            Dictionary<string, string> d = new Dictionary<string, string>()
                    {
                        { "@microsoft.graph.conflictBehavior", "replace" },
                        { "name", szFilename }
                    };
            Dictionary<string, object> d2 = new Dictionary<string, object>() { { "item", d } };
            using (StringContent sc = new StringContent(JsonConvert.SerializeObject(d2), System.Text.Encoding.UTF8, "application/json"))
            {
                using (HttpClient httpClient = new HttpClient())
                {
                    UriBuilder builder = BuilderForPath(String.Format(CultureInfo.InvariantCulture, "v1.0/drive/root:/{0}{1}:/createUploadSession", RootPath, szFilename));

                    try
                    {
                        response = await httpClient.PostAsync(builder.Uri, sc).ConfigureAwait(false);
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        return JsonConvert.DeserializeObject<OneDriveSession>(szResult);
                    }
                    catch (HttpRequestException ex)
                    {
                        if (response == null)
                            throw new MyFlightbookException("Unknown error in OneDrive.PutFileDirect", ex);
                        else
                            throw new OneDriveMFBException(new OneDriveError(szResult));
                    }
                    finally
                    {
                        if (response != null)
                            response.Dispose();
                        response = null;
                    }
                }
            }
        }

        public async Task<bool> PutFileDirect(string szFilename, Stream ms, string szMimeType)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));
            ms.Seek(0, SeekOrigin.Begin);
            try
            {
                await RefreshAccessToken().ConfigureAwait(false);
            }
            catch (DotNetOpenAuth.Messaging.ProtocolException ex)
            {
                HandleInvalidAuth(ex);
            }

            string szResult = string.Empty;
            HttpResponseMessage response = null;

            // See if we need to do a resumable session
            OneDriveSession session = (ms.Length > MinFileSizeResumable) ? await GetResumableSession(szFilename).ConfigureAwait(false) : null;

            using (StreamContent body = new StreamContent(ms))
            {
                body.Headers.ContentType = new MediaTypeHeaderValue(szMimeType);
                body.Headers.ContentDisposition = (new ContentDispositionHeaderValue("form-data") { Name = szFilename, FileName = szFilename });

                using (HttpClient httpClient = new HttpClient())
                {
                    try
                    {
                        UriBuilder builder = BuilderForPath(String.Format(CultureInfo.InvariantCulture, "v1.0/drive/root:/{0}{1}:/content", RootPath, szFilename));
                        if (session != null)
                        {
                            body.Headers.ContentLength = ms.Length;
                            body.Headers.ContentRange = new ContentRangeHeaderValue(0, ms.Length - 1, ms.Length) { Unit = "bytes" };
                        }
                        response = await httpClient.PutAsync(session == null ? builder.Uri : session.UploadUri, body).ConfigureAwait(false);
                        szResult = response.Content.ReadAsStringAsync().Result;
                        response.EnsureSuccessStatusCode();
                        return !String.IsNullOrEmpty(szResult);
                    }
                    catch (HttpRequestException ex)
                    {
                        if (response == null)
                            throw new MyFlightbookException("Unknown error in OneDrive.PutFileDirect", ex);
                        else
                            throw new OneDriveMFBException(new OneDriveError(szResult));
                    }
                    finally
                    {
                        if (response != null)
                            response.Dispose();
                    }
                }
            }
        }

        public async Task<bool> PutFileDirect(string szFileName, byte[] rgData, string szMimeType)
        {
            using (MemoryStream ms = new MemoryStream(rgData))
            {
                return await PutFileDirect(szFileName, ms, szMimeType).ConfigureAwait(false);
            }
        }
    }
    #endregion

    #region Dropbox
    /// <summary>
    /// Provides utilities for using Dropbox from MyFlightbook
    /// </summary>
    public class MFBDropbox: CloudStorageBase
    {
        public enum TokenStatus { None, oAuth1, oAuth2 }
        public const string szParamDropboxAuth = "dbOAuth";

        public MFBDropbox()
            : base("DropboxAccessID", "DropboxClientSecret", "https://www.dropbox.com/oauth2/authorize", "https://api.dropboxapi.com/oauth2/token", null, "https://api.dropboxapi.com/2/auth/token/from_oauth1", "https://api.dropboxapi.com/2/auth/token/revoke")
        {
        }

        /// <summary>
        /// Determines the type of dropbox oAuth token we have.  Optionally upgrades to an oAuth 2.0 credential and/or disables the existing one.
        /// MODIFIES THE IN MEMORY USER PROFILE to use an upgraded credential
        /// </summary>
        /// <param name="pf">The user profile</param>
        /// <param name="fCommit">True to update the database with the oAuth 2.0 credential</param>
        /// <returns>The state of the dropbox access token PRIOR to upgrade.</returns>
        async public Task<TokenStatus> ValidateDropboxToken(Profile pf, bool fCommit = false)
        {
            TokenStatus result = TokenStatus.None;

            if (pf == null || String.IsNullOrEmpty(pf.DropboxAccessToken))
                return result;

            try
            {
                string dbAppKey = AppKey;
                string dbSecret = AppSecret;

                byte[] rgbOAuth1Token = Convert.FromBase64String(pf.DropboxAccessToken);
                string xmlOAuth1Token = System.Text.Encoding.Default.GetString(rgbOAuth1Token);
                // if we get here, it is probably an oAuth1 token

                if (xmlOAuth1Token.Trim().StartsWith("<", StringComparison.OrdinalIgnoreCase))
                {
                    string szRawToken = null;
                    string szRawSecret = null;

                    using (MemoryStream stream = new MemoryStream(rgbOAuth1Token))
                    {
                        System.Runtime.Serialization.DataContractSerializer serializer = new System.Runtime.Serialization.DataContractSerializer(typeof(Dictionary<string, string>));
                        Object o = serializer.ReadObject(stream);
                        if (o.GetType().Equals(typeof(Dictionary<string, string>)))
                        {
                            Dictionary<string, string> d = (Dictionary<string, string>)o;
                            szRawToken = d["TokenDropBoxUsername"];
                            szRawSecret = d["TokenDropBoxPassword"];
                        }
                    }


                    try
                    {
                        using (DropboxAppClient client = new DropboxAppClient(dbAppKey, dbSecret))
                        {
                            var tokenFromOAuth1Result = await client.Auth.TokenFromOauth1Async(szRawToken, szRawSecret).ConfigureAwait(false);
                            pf.DropboxAccessToken = tokenFromOAuth1Result.Oauth2Token;
                        }

                        if (fCommit)
                            pf.FCommit();

                        result = TokenStatus.oAuth1;
                    }
                    catch (Exception ex) when (ex is WebException)
                    {
                    }
                }
                else
                    result = TokenStatus.oAuth2;
            }
            catch (Exception ex) when (ex is FormatException)
            {
                // It should be v2!
                result = TokenStatus.oAuth2;
            }
            return result;
        }

        /// <summary>
        /// Put's a file as an array of bytes
        /// </summary>
        /// <param name="szDropboxAccessToken">The oAuth 2.0 access token</param>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="rgData">The array of bytes</param>
        /// <returns>FileMetadata with the result</returns>
        public async static Task<Dropbox.Api.Files.FileMetadata> PutFile(string szDropboxAccessToken, string szFileName, byte[] rgData)
        {
            using (MemoryStream ms = new MemoryStream(rgData))
            {
                return await PutFile(szDropboxAccessToken, ms, szFileName).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Put's a file as a stream
        /// </summary>
        /// <param name="szDropboxAccessToken">The oAuth 2.0 access token</param>
        /// <param name="szFileName">The file name to use</param>
        /// <param name="ms">The stream of the data</param>
        /// <returns>FileMetadata with the result</returns>
        public async static Task<Dropbox.Api.Files.FileMetadata> PutFile(string szDropboxAccessToken, Stream ms, string szFileName)
        {
            if (ms == null)
                throw new ArgumentNullException(nameof(ms));
            ms.Seek(0, SeekOrigin.Begin);   // write out the whole stream.  UploadAsync appears to pick up from the current location, which is the end-of-file after writing to a ZIP.
            using (DropboxClient dbx = new DropboxClient(szDropboxAccessToken))
            {
                Dropbox.Api.Files.FileMetadata updated = await dbx.Files.UploadAsync("/" + szFileName, Dropbox.Api.Files.WriteMode.Overwrite.Instance, body: ms).ConfigureAwait(false);
                return updated;
            }
        }
    }
    #endregion
}